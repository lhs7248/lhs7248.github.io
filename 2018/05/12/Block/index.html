<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="什么是Block ？在wikipedia 上，闭包的定义如下：  In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-c">
<meta property="og:type" content="article">
<meta property="og:title" content="Block">
<meta property="og:url" content="http://example.com/2018/05/12/Block/index.html">
<meta property="og:site_name" content="lhs7248的博客">
<meta property="og:description" content="什么是Block ？在wikipedia 上，闭包的定义如下：  In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-c">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2018/05/12/Block/16c092417f50345c.png">
<meta property="article:published_time" content="2018-05-12T11:46:34.000Z">
<meta property="article:modified_time" content="2021-02-23T08:18:29.475Z">
<meta property="article:author" content="lhs728">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2018/05/12/Block/16c092417f50345c.png">

<link rel="canonical" href="http://example.com/2018/05/12/Block/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Block | lhs7248的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2c28b34ebf94902f8372b65ff331f6e1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lhs7248的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录一点有意义的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lhs7248" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/05/12/Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhs728">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhs7248的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Block
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-12 19:46:34" itemprop="dateCreated datePublished" datetime="2018-05-12T19:46:34+08:00">2018-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-23 16:18:29" itemprop="dateModified" datetime="2021-02-23T16:18:29+08:00">2021-02-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="什么是Block-？"><a href="#什么是Block-？" class="headerlink" title="什么是Block ？"></a>什么是Block ？</h3><p>在wikipedia 上，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a>的定义如下：</p>
<blockquote>
<p>In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function[a] together with an environment.The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.</p>
</blockquote>
<p>block 实际上就是 Objective-C 语言对于闭包的实现。</p>
<a id="more"></a>

<h3 id="Block基本使用"><a href="#Block基本使用" class="headerlink" title="Block基本使用"></a>Block基本使用</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">WorkingwithBlocks</a></p>
<h4 id="无参数无返回值："><a href="#无参数无返回值：" class="headerlink" title="无参数无返回值："></a>无参数无返回值：</h4><pre><code>//无参无返回值的定义和使用
void (^LSBlock1)(void) = ^&#123;
      NSLog(@&quot;无参无返回值&quot;);
&#125;;

// 调用
LSBlock1();</code></pre>
<h4 id="无参有返回值："><a href="#无参有返回值：" class="headerlink" title="无参有返回值："></a>无参有返回值：</h4><pre><code>// 无参有返回值
int (^ LSBlock2)(void) = ^&#123;
    NSLog(@&quot;无参有返回值&quot;);
    return 2;
&#125;;
// 调用
int res = LSBlock2();</code></pre>
<h4 id="有参无返回值："><a href="#有参无返回值：" class="headerlink" title="有参无返回值："></a>有参无返回值：</h4><pre><code>//有参无返回值 定义
void (^ LSBlock3)(int a) = ^(int a)&#123;
    NSLog(@&quot;有参无返回值 a = %d&quot;,a);
&#125;;

// 调用
LSBlock3(10);</code></pre>
<h4 id="有参有返回值："><a href="#有参有返回值：" class="headerlink" title="有参有返回值："></a>有参有返回值：</h4><pre><code>//有参有返回值
int (^ LSBlock4)(int a) = ^(int a)&#123;
    NSLog(@&quot;有参有返回值 a = %d&quot;,a);
    return a * 2;
&#125;;
LSBlock4(4);</code></pre>
<h4 id="定义Block类型："><a href="#定义Block类型：" class="headerlink" title="定义Block类型："></a>定义Block类型：</h4><pre><code>typedef int (^LSBlock)(int a, int b);</code></pre>
<h4 id="Function中block参数："><a href="#Function中block参数：" class="headerlink" title="Function中block参数："></a>Function中block参数：</h4><pre><code>- (void)doSomethingWithBlock:(void (^)(double, double))block &#123;
...
block(21.0, 2.0);</code></pre>
<p>}</p>
<h3 id="Block数据结构及类型"><a href="#Block数据结构及类型" class="headerlink" title="Block数据结构及类型"></a>Block数据结构及类型</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>源码如下：</p>
<pre><code>  int age = 20;

  void (^LSBlock)(void) =  ^&#123;
       NSLog(@&quot;age is %d&quot;,age);
   &#125;;

  LSBlock();</code></pre>
</li>
<li><p>打开终端，cd到当前的目录</p>
<p>  执行如下的命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code> 生成.cpp文件</p>
</li>
</ul>
<ul>
<li><p>代码结构</p>
<pre><code>  static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;
    int age = __cself-&gt;age; // bound by copy  值的copy

           NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8h__1jd148j4p379rtpx4yzb83h0000gn_T_main_595f3d_mi_0,age);
       &#125;

  static struct __main_block_desc_0 &#123;
    size_t reserved;
    size_t Block_size;
  &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;

  int main(int argc, char * argv[]) &#123;
      int age = 20;
      void (*LSBlock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));

      ((void (*)(__block_impl *))((__block_impl *)LSBlock)-&gt;FuncPtr)((__block_impl *)LSBlock);
  &#125;</code></pre>
<p>  方法简化为如下：</p>
<pre><code>  int age = 20;
   void (*LSBlock)(void) =  __main_block_impl_0((void *)__main_block_func_0,
                                       &amp;__main_block_desc_0_DATA, 
                                       age)
  LSBlock-&gt;FuncPtr(LSBlock)</code></pre>
<p>  __main_block_impl_0的实现如下：</p>
<pre><code>  struct __main_block_impl_0 &#123;
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    int age;
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123;
      impl.isa = &amp;_NSConcreteStackBlock;
      impl.Flags = flags;
      impl.FuncPtr = fp;
      Desc = desc;
    &#125;
  &#125;;</code></pre>
<p>  <code>struct __block_impl impl</code>的实现：</p>
<pre><code>  struct __block_impl &#123;
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
  &#125;;</code></pre>
<p>  <code>__main_block_desc_0 </code>的实现：</p>
<pre><code>  static struct __main_block_desc_0 &#123;
    size_t reserved;
    size_t Block_size; // 结构体__main_block_impl_0 占用的内存大小
  &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</code></pre>
<p>  <code>age</code> 捕获的局部变量:</p>
<pre><code>  static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;
    int age = __cself-&gt;age; // bound by copy  值的copy

           NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8h__1jd148j4p379rtpx4yzb83h0000gn_T_main_595f3d_mi_0,age);
  &#125;</code></pre>
</li>
</ul>
<h4 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h4><p>局部变量（auto）:</p>
<ol>
<li><p>源码：</p>
<pre><code>     int age = 20;

     void (^LSBlock)(void) =  ^&#123;
          NSLog(@&quot;age is %d&quot;,age);
      &#125;;

     age = 30;

     LSBlock();</code></pre>
</li>
<li><p>源码分析，</p>
<pre><code>     static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;
       int age = __cself-&gt;age; // bound by copy  值的copy

          NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8h__1jd148j4p379rtpx4yzb83h0000gn_T_main_595f3d_mi_0,age);
     &#125;</code></pre>
</li>
<li><p>结论</p>
<pre><code> 直接把age的值 20传到了结构体__main_block_impl_0中，后面再修改age = 25并不能改变block里面的值</code></pre>
</li>
</ol>
<p>局部变量（static）</p>
<ol>
<li><p>源码如下：</p>
<pre><code> int age = 20;
 static int height  = 30;
 void (^LSBlock)(void) =  ^&#123;

     NSLog(@&quot;age is %d height %d&quot;,age,height);
  &#125;;

 height = 35;
 LSBlock();    </code></pre>
</li>
<li><p>源码分析：</p>
<pre><code> static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;
   int age = __cself-&gt;age; // bound by copy
   int *height = __cself-&gt;height; // bound by copy

          NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8h__1jd148j4p379rtpx4yzb83h0000gn_T_main_9dbf06_mi_0,age,(*height));
      &#125;</code></pre>
</li>
<li><p>结论</p>
<pre><code> age是直接值传递，height传递的是*height 也就是说直接把内存地址传进去。</code></pre>
</li>
</ol>
<p>全局变量:</p>
<ol>
<li><p>源码如下：</p>
<pre><code> int age = 20;
 static int height  = 30;

 int main(int argc, char * argv[]) &#123;</code></pre>
</li>
</ol>
<pre><code>        void (^LSBlock)(void) =  ^&#123;

            NSLog(@&quot;age is %d height %d&quot;,age,height);
         &#125;;

        height = 35;
        LSBlock();
    &#125;</code></pre>
<ol start="2">
<li><p>源码分析</p>
<pre><code> static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</code></pre>
</li>
</ol>
<pre><code>        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8h__1jd148j4p379rtpx4yzb83h0000gn_T_main_3ddd41_mi_0,age,height);

     &#125;</code></pre>
<ol start="3">
<li><p>结论</p>
<pre><code> 并没有捕获全局变量age和height,访问的时候，是直接去访问的，根本不需要捕获</code></pre>
</li>
</ol>
<h4 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h4><ol>
<li><p>Block 是一个OC对象：</p>
<p> 根据block的数据结构，block中有isa指针，block是一个oc对象，验证如下：</p>
<pre><code>void (^block)(void) =  ^&#123;
      NSLog(@&quot;this is GlobalBlock&quot;);
&#125;;

NSLog(@&quot;block.class = %@&quot;,[block class]);
NSLog(@&quot;block.class.superclass = %@&quot;,[[block class] superclass]);
NSLog(@&quot;block.class.superclass.superclass = %@&quot;,[[[block class] superclass] superclass]);

输出结果：
 block.class = __NSGlobalBlock__
 block.class.superclass = NSBlock
 block.class.superclass.superclass = NSObject
 block.class.superclass.superclass.superclass = (null)</code></pre>
<p>block的类型是<code>__NSGlobalBlock__</code>，继承关系可以表示为<code>__NSGlobalBlock__ : NSBlock : NSObject</code></p>
</li>
</ol>
<ol start="2">
<li><p>Block的类型:</p>
<p> <a href="">栈、堆、数据区域</a></p>
<table>
<thead>
<tr>
<th>Block类型</th>
<th>存储区</th>
<th>环境</th>
<th>拷贝效果</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>_NSConcreteStatckBlock</td>
<td>栈</td>
<td>访问了auto变量</td>
<td>从栈拷贝到堆，往flags中并入BLOCK_NEEDS_FREE这个标志表明block需要释放，在release以及再次拷贝时会用到）；如果有辅助拷贝函数，就调用，将捕获的变量从栈拷贝到堆中</td>
<td>出了作用域</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td><code>_NSStackBlock__</code>调用了copy</td>
<td>单纯的引用计数加一</td>
<td>引用计数为0，runloop结束后释放</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>全局数据区</td>
<td>没有访问auto变量</td>
<td>什么都不做，直接返回Blcok</td>
<td>app整个生命周期</td>
</tr>
</tbody></table>
<p> 在MRC下验证代码：</p>
<pre><code> void (^LSBlock)(void) =  ^&#123;
        NSLog(@&quot;123&quot;);
 &#125;;

 NSLog(@&quot;没有访问auto LSBlock.class = %@&quot;,[LSBlock class]);

 int a = 10;
 void (^LSBlock1)(void) =  ^&#123;
       NSLog(@&quot;a = %d&quot;,a);
 &#125;;

 NSLog(@&quot;访问了auto LSBlock1.class = %@&quot;,[LSBlock1 class]);

 NSLog(@&quot;访问量auto 并且copy LSBlock1-copy.class = %@&quot;,[[LSBlock1 copy] class]);</code></pre>
<p> 输出结果如下：</p>
<pre><code> 没有访问auto LSBlock.class = __NSGlobalBlock__
 访问了auto LSBlock1.class = __NSStackBlock__
 访问量auto 并且copy LSBlock1-copy.class = __NSMallocBlock__</code></pre>
<p> 在ARC下，因为编译器做了copy，输出结果如下：</p>
<pre><code> 没有访问auto LSBlock.class = __NSGlobalBlock__
 访问了auto LSBlock1.class = __NSMallocBlock__
 访问量auto 并且copy LSBlock1-copy.class = __NSMallocBlock__</code></pre>
</li>
<li><p>Block的Copy</p>
<p> <img src="/2018/05/12/Block/16c092417f50345c.png" alt="alt"></p>
<ul>
<li><p>MRC 下block的建议写法</p>
<p>  <code>@property (copy, nonatomic) void (^block)(void);</code></p>
</li>
<li><p>ARC 下block的建议写法</p>
<p>  <code>@property (strong, nonatomic) void (^block)(void);</code></p>
<p>  <code>@property (copy, nonatomic) void (^block)(void);</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="对象类型auto变量"><a href="#对象类型auto变量" class="headerlink" title="对象类型auto变量"></a>对象类型auto变量</h3><h4 id="例子如下："><a href="#例子如下：" class="headerlink" title="例子如下："></a>例子如下：</h4><ol>
<li><p>定义如下的对象类型</p>
<pre><code> @interface LSDog : NSObject
 @property (nonatomic ,assign) int age;
 @end

 @implementation LSDog
 -(void)dealloc
 &#123;
     NSLog(@&quot;Dog--%s&quot;,__func__);
 &#125;
 @end</code></pre>
</li>
</ol>
<ol start="2">
<li><p>ARC下引用实例对象：</p>
<pre><code> typedef void (^LSBlock)(void);

 int main(int argc, char * argv[]) &#123;

     @autoreleasepool &#123;

         LSBlock block;

            &#123;
                LSDog *dog = [[LSDog alloc] init];
                dog.age = 10;

                block = ^&#123;
                    NSLog(@&quot;---------%d&quot;, dog.age);
                &#125;;
                NSLog(@&quot;block.class = %@&quot;,[block class]);
            &#125;
            NSLog(@&quot;block销毁&quot;);
     &#125;
 &#125;</code></pre>
<p> 输出结如下：</p>
<pre><code>  block.class = __NSMallocBlock__
  block销毁
  Dog---[LSDog dealloc]</code></pre>
<p> ARC的情况下<code>__main_block_impl_0</code>实现如下：</p>
<pre><code> struct __main_block_impl_0 &#123;
   struct __block_impl impl;
   struct __main_block_desc_0* Desc;
   LSDog *__strong dog;
   __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, LSDog *__strong _dog, int flags=0) : dog(_dog) &#123;
     impl.isa = &amp;_NSConcreteStackBlock;
     impl.Flags = flags;
     impl.FuncPtr = fp;
     Desc = desc;
   &#125;
 &#125;;</code></pre>
</li>
<li><p>MRC下引用实例对象：</p>
<pre><code> typedef void (^LSBlock)(void);

 int main(int argc, char * argv[]) &#123;

     @autoreleasepool &#123;

         LSBlock block;

            &#123;
                LSDog *dog = [[LSDog alloc] init];
                dog.age = 10;

                block = ^&#123;
                    NSLog(@&quot;---------%d&quot;, dog.age);
                &#125;;
                NSLog(@&quot;block.class = %@&quot;,[block class]);
                [dog release];
            &#125;
         [block release];

         NSLog(@&quot;block销毁&quot;);
     &#125;
 &#125;</code></pre>
<p> 输出结如下：</p>
<pre><code>  block.class = __NSStackBlock__
  Dog---[LSDog dealloc]
  block销毁</code></pre>
<p> MRC的情况下<code>__main_block_impl_0</code>实现如下：</p>
<pre><code> struct __main_block_impl_0 &#123;
   struct __block_impl impl;
   struct __main_block_desc_0* Desc;
   LSDog *dog;
   __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, LSDog *_dog, int flags=0) : dog(_dog) &#123;
     impl.isa = &amp;_NSConcreteStackBlock;
     impl.Flags = flags;
     impl.FuncPtr = fp;
     Desc = desc;
   &#125;
 &#125;;     </code></pre>
</li>
<li><p>结论    ：</p>
<ul>
<li>当 block为<code>__NSStackBlock__</code>类型时候，block不可以保住dog的命</li>
<li>当 block为<code>__NSMallocBlock__</code>类型时候，block是可以保住dog的命，对dog的引用为强引用。</li>
</ul>
</li>
</ol>
<h3 id="Block的修饰符"><a href="#Block的修饰符" class="headerlink" title="Block的修饰符"></a>Block的修饰符</h3><h4 id="Weak-修饰"><a href="#Weak-修饰" class="headerlink" title="__Weak 修饰"></a>__Weak 修饰</h4><ul>
<li><p>在ARC的情况下，不使用修饰符修饰OC对象：</p>
<p>  源码如下：</p>
<pre><code>  // 定义block
  typedef void (^LSBlock)(void);

  int main(int argc, char * argv[]) &#123;

      @autoreleasepool &#123;

          LSBlock block;
             &#123;
              LSDog * dog = [[LSDog alloc] init];
                 dog.age = 10;

                 block = ^&#123;
                     NSLog(@&quot;---------%d&quot;, dog.age);
                 &#125;;
                 NSLog(@&quot;block.class = %@&quot;,[block class]);
             &#125;

          NSLog(@&quot;block销毁&quot;);
      &#125;
  &#125;</code></pre>
<p>  <code>__main_block_impl_0</code>实现如下：</p>
<pre><code>  struct __main_block_impl_0 &#123;
        struct __block_impl impl;
        struct __main_block_desc_0* Desc;
        LSDog *__strong dog;
        __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, LSDog *__strong _dog, int flags=0) : dog(_dog) &#123;
          impl.isa = &amp;_NSConcreteStackBlock;
          impl.Flags = flags;
          impl.FuncPtr = fp;
          Desc = desc;
        &#125;
      &#125;;</code></pre>
</li>
<li><p>使用__weak 修饰OC对象</p>
<p>  源码如下：</p>
<pre><code>  // 定义block
  typedef void (^LSBlock)(void);

  int main(int argc, char * argv[]) &#123;

      @autoreleasepool &#123;

          LSBlock block;

             &#123;
                 __weak LSDog *weakDog = [[LSDog alloc] init];
                 weakDog.age = 10;

                 block = ^&#123;
                     NSLog(@&quot;---------%d&quot;, weakDog.age);
                 &#125;;
                 NSLog(@&quot;block.class = %@&quot;,[block class]);
             &#125;

          NSLog(@&quot;block销毁&quot;);
      &#125;
  &#125;</code></pre>
<p>  输出结果如下：</p>
<pre><code>  Dog---[LSDog dealloc]
  block.class = __NSMallocBlock__
  block销毁</code></pre>
<p>  <code>__main_block_impl_0</code>实现如下：</p>
<pre><code>  static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;
    LSDog *__weak weakDog = __cself-&gt;weakDog; // bound by copy

                     NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8h__1jd148j4p379rtpx4yzb83h0000gn_T_main_250460_mi_0, ((int (*)(id, SEL))(void *)objc_msgSend)((id)weakDog, sel_registerName(&quot;age&quot;)));
                 &#125;

  static struct __main_block_desc_0 &#123;
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
    void (*dispose)(struct __main_block_impl_0*);
  &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;

  //copy函数内部会调用_Block_object_assign函数,_Block_object_assign会对对象进行强引用或者弱引用
  static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;weakDog, (void*)src-&gt;weakDog, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;

  //dispose函数内部会调用_Block_object_dispose函数
  static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;weakDog, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</code></pre>
<table>
<thead>
<tr>
<th>函数</th>
<th>调用时机</th>
</tr>
</thead>
<tbody><tr>
<td>copy函数</td>
<td>栈上的Block复制到堆上</td>
</tr>
<tr>
<td>dispose函数</td>
<td>堆上的block被废弃时</td>
</tr>
</tbody></table>
</li>
<li><p>小结</p>
<ol>
<li>当block为<code>__NSStackBlock__</code>类型时候，是在栈空间，无论对外面使用的是strong 还是weak 都不会对外面的对象进行强引用</li>
<li>当block为_<code>_NSMallocBlock__</code>类型时候，是在堆空间，block是内部的_Block_object_assign函数会根据strong或者 weak对外界的对象进行强引用或者弱引用。</li>
</ol>
</li>
</ul>
<h4 id="block"><a href="#block" class="headerlink" title="__block"></a><code>__block</code></h4><ul>
<li><p>Block 内部修改局部变量的方式</p>
<ol>
<li>把变量改为全局变量，因为全局变量，是所有地方都可访问的，在block内部可以直接操作age的内存地址的。</li>
<li>使用static 修饰，当局部变量用static修饰之后，这个block内部会有个成员是int *age，也就是说把age的地址捕获了</li>
<li>使用<code>__block </code>来修饰。</li>
</ol>
</li>
<li><p>__block 修饰</p>
<p>  源码如下：</p>
<pre><code>  // 定义block
  typedef void (^LSBlock)(void);

  int main(int argc, char * argv[]) &#123;
      @autoreleasepool &#123;

         __block int age = 10;

          LSBlock block = ^&#123;
              NSLog(@&quot;age %d&quot;,age);
          &#125;;

          NSLog(@&quot;block.class = %@&quot;,[block class]);
          age = 20;

          block();
      &#125;            
  &#125;</code></pre>
<p>  使用<code>终端执行这行指令xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m </code>把main.m生成main.cpp。查看生成文件，发现多了如下的操作：</p>
<pre><code>  // 生成的代码
  __attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;

  //这是格式化之后的代码 __Block_byref_age_0
  __Block_byref_age_0 age = &#123;
       0, //赋值给 __isa
       (__Block_byref_age_0 *)&amp;age,//赋值给 __forwarding,也就是自身的指针
        0, // 赋值给__flags
        sizeof(__Block_byref_age_0),//赋值给 __size
        10 // age 使用值
      &#125;;</code></pre>
<p>  <code>__Block_byref_age_0</code>的实现如下：</p>
<pre><code>  struct __Block_byref_age_0 &#123;
    void *__isa;
  __Block_byref_age_0 *__forwarding;
   int __flags;
   int __size;
   int age;
  &#125;;</code></pre>
<p>  <code>__main_block_impl_0</code></p>
<pre><code>  //__Block_byref_age_0  block调用的时候是调用的 age(_age-&gt;__forwarding）指向的是自己的指针。
  struct __main_block_impl_0 &#123;
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    __Block_byref_age_0 *age; // by ref
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;
      impl.isa = &amp;_NSConcreteStackBlock;
      impl.Flags = flags;
      impl.FuncPtr = fp;
      Desc = desc;
    &#125;
  &#125;;</code></pre>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li><p>在ARC的情况下：</p>
<p>  源码如下：</p>
<pre><code>  int num = 8;
  __block int age = 10;
  NSObject *obj = [[NSObject alloc]init];
  NSObject *obj2 = [[NSObject alloc]init];
  __weak NSObject *weakObj2 = obj2;
  LSBlock block = ^&#123;

      NSLog(@&quot;age = %d&quot;,age);
      NSLog(@&quot;num = %d&quot;,num);
      NSLog(@&quot;obj = %p&quot;,obj);
      NSLog(@&quot;weakObj2 = %p&quot;,weakObj2);
      NSLog(@&quot;block内部修改之后age = %d&quot;,age);
  &#125;;</code></pre>
<p>  实现如下：</p>
<pre><code>  struct __main_block_impl_0 &#123;
    struct __block_impl impl;
    struct __main_block_desc_0* Desc;
    int num;
    NSObject *__strong obj;
    NSObject *__weak weakObj2;
    __Block_byref_age_0 *age; // by ref
    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _num, NSObject *__strong _obj, NSObject *__weak _weakObj2, __Block_byref_age_0 *_age, int flags=0) : num(_num), obj(_obj), weakObj2(_weakObj2), age(_age-&gt;__forwarding) &#123;
      impl.isa = &amp;_NSConcreteStackBlock;
      impl.Flags = flags;
      impl.FuncPtr = fp;
      Desc = desc;
    &#125;
  &#125;;</code></pre>
</li>
<li><p>当不使用修饰符的时候</p>
<ol>
<li>当block在栈上时，对它们都不会产生强引用</li>
<li>当block拷贝到堆上时，都会通过copy函数来处理它们</li>
</ol>
</li>
<li><p>当使用__block 修饰</p>
<ol>
<li><code>_Block_object_assign((void*)&amp;dst-&gt;dog, (void*)src-&gt;dog, 8/*BLOCK_FIELD_IS_BYREF*/)</code>，会根据修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用。（ARC模式下）</li>
<li><code>_Block_object_dispose((void*)src-&gt;dog, 8/*BLOCK_FIELD_IS_BYREF*/)</code></li>
</ol>
</li>
</ul>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><h4 id="循环引用的原因"><a href="#循环引用的原因" class="headerlink" title="循环引用的原因"></a>循环引用的原因</h4><ul>
<li><p>常见的情况下是由于Block内部对外部对象的强引用造成的，例如：</p>
<pre><code>  typedef void (^LSBlock)(void);

  NS_ASSUME_NONNULL_BEGIN

  @interface LSDog : NSObject
  @property (nonatomic ,assign) int age;
  @property (copy, nonatomic) LSBlock block;
  @end

  LSDog * dog = [[LSDog alloc] init];

  dog.block = ^&#123;

      NSLog(@&quot;dog %d&quot;,dog.age);
  &#125;;</code></pre>
</li>
</ul>
<h4 id="解决循环引用的方式"><a href="#解决循环引用的方式" class="headerlink" title="解决循环引用的方式"></a>解决循环引用的方式</h4><ul>
<li>针对block内部对外部变量的强引用，建议是用<code>__weak</code>进行修饰。</li>
<li><code>__unsafe_unretained</code>可以解决循环引用。在MRC下，因为不支持弱指针<code>__weak</code>，所以，只能是<code>__unsafe_unretained</code>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/Block-ABI-Apple.html">llvm-block</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/04/13/gitCommand/" rel="prev" title="Git 常用的命令行">
      <i class="fa fa-chevron-left"></i> Git 常用的命令行
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/07/28/ios-touch-event-responder/" rel="next" title="iOS 触摸事件如何进行响应">
      iOS 触摸事件如何进行响应 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBlock-%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是Block ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">Block基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">无参数无返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">无参有返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A"><span class="nav-number">2.3.</span> <span class="nav-text">有参无返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A"><span class="nav-number">2.4.</span> <span class="nav-text">有参有返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Block%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">2.5.</span> <span class="nav-text">定义Block类型：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function%E4%B8%ADblock%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="nav-number">2.6.</span> <span class="nav-text">Function中block参数：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">Block数据结构及类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7"><span class="nav-number">3.2.</span> <span class="nav-text">变量捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Block%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">Block的类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8Bauto%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">对象类型auto变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="nav-number">4.1.</span> <span class="nav-text">例子如下：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Block%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">Block的修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Weak-%E4%BF%AE%E9%A5%B0"><span class="nav-number">5.1.</span> <span class="nav-text">__Weak 修饰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#block"><span class="nav-number">5.2.</span> <span class="nav-text">__block</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">循环引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">7.1.</span> <span class="nav-text">循环引用的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">解决循环引用的方式</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lhs728</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lhs7248" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lhs7248" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lhs7248@126.com" title="E-Mail → mailto:lhs7248@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lhs728</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">207k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:09</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
