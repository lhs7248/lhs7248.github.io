<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="主键表中的任何列都可以作为主键，只要它满足以下条件:  任意两行都不具有相同的主键值; 每一行都必须具有一个主键值(主键列不允许 NULL 值); 主键列中的值不允许修改或更新; 主键值不能重用(如果某行从表中删除，它的主键不能赋给以后的新行)。  数据检索 一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。   select  prod_id,prod_name, prod_pric">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL_Learn">
<meta property="og:url" content="http://example.com/2019/04/19/SQL-Learn/index.html">
<meta property="og:site_name" content="lhs7248的博客">
<meta property="og:description" content="主键表中的任何列都可以作为主键，只要它满足以下条件:  任意两行都不具有相同的主键值; 每一行都必须具有一个主键值(主键列不允许 NULL 值); 主键列中的值不允许修改或更新; 主键值不能重用(如果某行从表中删除，它的主键不能赋给以后的新行)。  数据检索 一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。   select  prod_id,prod_name, prod_pric">
<meta property="og:locale">
<meta property="article:published_time" content="2019-04-19T05:57:30.000Z">
<meta property="article:modified_time" content="2021-02-19T06:20:40.907Z">
<meta property="article:author" content="lhs728">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2019/04/19/SQL-Learn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>SQL_Learn | lhs7248的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2c28b34ebf94902f8372b65ff331f6e1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">lhs7248的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录一点有意义的事</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lhs7248" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/04/19/SQL-Learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lhs728">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lhs7248的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SQL_Learn
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-19 13:57:30" itemprop="dateCreated datePublished" datetime="2019-04-19T13:57:30+08:00">2019-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-19 14:20:40" itemprop="dateModified" datetime="2021-02-19T14:20:40+08:00">2021-02-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>表中的任何列都可以作为主键，只要它满足以下条件:</p>
<ol>
<li>任意两行都不具有相同的主键值;</li>
<li>每一行都必须具有一个主键值(主键列不允许 NULL 值);</li>
<li>主键列中的值不允许修改或更新;</li>
<li>主键值不能重用(如果某行从表中删除，它的主键不能赋给以后的新行)。</li>
</ol>
<h4 id="数据检索"><a href="#数据检索" class="headerlink" title="数据检索"></a>数据检索</h4><blockquote>
<p>一般而言，除非你确实需要表中的每一列，否则最好别使用*通配符。</p>
</blockquote>
<ol>
<li><p><code>select  prod_id,prod_name, prod_price from  Products;</code></p>
</li>
<li><p><code>select * from Products;</code> </p>
</li>
<li><p><code>select DISTINCT vend_id from Products;</code> DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例 如，你指定 SELECT DISTINCT vend_id, prod_price，除非指定的 两列完全相同，否则所有的行都会被检索出来。</p>
</li>
<li><p><code>SELECT prod_name FROM Products LIMIT 5 Offset 5;</code> LIMIT 指定返回的行数。LIMIT 带的 OFFSET 指定从哪儿开始</p>
</li>
<li><p><code>SELECT prod_name  --这是一条注释 FROM Products LIMIT 5 Offset 5;</code>  –这是一条注释</p>
</li>
</ol>
<h4 id="数据排序检索"><a href="#数据排序检索" class="headerlink" title="数据排序检索"></a>数据排序检索</h4><ol start="6">
<li><p><code>SELECT prod_name FROM Products ORDER BY prod_name;</code> 在指定一条 ORDER BY 子句时，应该保证它是 SELECT 语句中最后一 条子句</p>
</li>
<li><p><code>SELECT prod_id, prod_price, prod_name FROM Products ORDER BY 2, 3;</code> 按位置排序，优先按2 后按 3 的位置进行排序</p>
</li>
<li><p><code>SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC, prod_name;</code>使用DESC 降序排列，只对prod_price DESC, 字段生效</p>
</li>
</ol>
<h4 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h4><ol>
<li><p><code>SELECT prod_name, prod_price FROM Products WHERE prod_price = 3.49;</code> 数据根据 WHERE 子句中指定的搜索条件进行过滤。</p>
</li>
<li><p>WHERE子句操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>!&lt;</td>
<td>不小于</td>
</tr>
<tr>
<td>!&gt;</td>
<td>不大于</td>
<td>BETWEEN</td>
<td>在指定的两个值之间</td>
</tr>
<tr>
<td>IS NULL</td>
<td>为NULL值</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>单引号用来限定字符串。如果将值与字符串类型的 列进行比较，就需要限定引号。用来与数值列进行比较的值不用引号:</p>
</li>
</ol>
<ul>
<li><code>SELECT prod_name, prod_price FROM Products WHERE prod_price BETWEEN 5 AND 10;</code> 区间查询</li>
<li><code>SELECT cust_name FROM CUSTOMERS WHERE cust_email IS NULL; </code> 空值检查</li>
</ul>
<h4 id="高级数据过滤"><a href="#高级数据过滤" class="headerlink" title="高级数据过滤"></a>高级数据过滤</h4><ol>
<li><p><code>SELECT prod_id, prod_price, prod_name  FROM Products WHERE vend_id = &#39;DLL01&#39; AND prod_price &lt;= 4;</code>AND<br>用在 WHERE 子句中的关键字，用来指示检索满足所有给定条件的行。</p>
</li>
<li><p><code>SELECT prod_name, prod_price,vend_id FROM Products WHERE vend_id = &#39;DLL01&#39; OR vend_id = &#39;BRS01&#39;;</code>OR<br>WHERE 子句中使用的关键字，用来表示检索匹配任一给定条件的行。</p>
</li>
<li><p><code>SELECT prod_name, prod_price FROM Products WHERE vend_id = &#39;DLL01&#39; AND prod_price &gt;= 10</code> 由于 AND 在求值过程中优先级更高，操作符被错误地组合了</p>
</li>
<li><p><code>SELECT prod_name, prod_price FROM Products WHERE (vend_id = &#39;DLL01&#39; OR vend_id = &#39;BRS01&#39;) AND prod_price &gt;= 10;</code>任何时候使用具有 AND 和 OR 操作符的 WHERE 子句，都应该使用圆括 号明确地分组操作符</p>
</li>
<li><p><code>SELECT prod_name, prod_price FROM Products WHERE vend_id IN ( &#39;DLL01&#39;, &#39;BRS01&#39; ) ORDER BY prod_name;</code><br> 为什么要使用 IN 操作符?其优点如下。</p>
<ul>
<li>在有很多合法选项时，IN 操作符的语法更清楚，更直观。</li>
<li>在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。</li>
<li>IN 操作符一般比一组 OR 操作符执行得更快(在上面这个合法选项很<br>少的例子中，你看不出性能差异)。</li>
<li>IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立<br>WHERE 子句。第 11 课会对此进行详细介绍。</li>
</ul>
</li>
<li><p><code>SELECT prod_name FROM Products WHERE NOT vend_id = &#39;DLL01&#39; ORDER BY prod_name;</code>这里的 NOT 否定跟在其后的条件，因此，DBMS 不是匹配 vend_id 为<br>DLL01，而是匹配非 DLL01 之外的所有东西。</p>
</li>
</ol>
<h4 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h4><h5 id="LIKE-操作符"><a href="#LIKE-操作符" class="headerlink" title="LIKE 操作符"></a>LIKE 操作符</h5><ol>
<li><p><code>SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE &#39;Fish%&#39;;</code> 最常使用的通配符是百分号(%)。在搜索串中，%表示任何字符出现任意次<br>数</p>
</li>
<li><p><code>SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE &#39;%bean bag%&#39;;</code>% 代表搜索模式中给定位置的 0 个、1 个或多个字符。<br>注意:请注意 NULL 通配符%看起来像是可以匹配任何东西，但有个例外，这就是 NULL。 子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL的行。</p>
</li>
<li><p><code>SELECT prod_id, prod_name FROM Products WHERE prod_name LIKE &#39;__ inch teddy bear&#39;;</code> 下划线的用途与%一样，但它只匹配 单个字符，而不是多个字符。</p>
</li>
<li><p><code>SELECT cust_contact FROM Customers WHERE cust_contact LIKE &#39;[JM]%&#39; ORDER BY cust_contact</code></p>
</li>
<li><p>方括号([])通配符用来指定一个字符集，它必须匹配指定位置(通配 符的位置)的一个字符。</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用 其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始 处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 总之，通配符是一种极其重要和有用的搜索工具，以后我们经常会用<br>到它。</li>
</ul>
</li>
</ol>
<h4 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h4><blockquote>
<p>计算 字段并不实际存在于数据库表中。计算字段是运行时在 SELECT 语句内 创建的。</p>
</blockquote>
<ol>
<li><p><code>SELECT vend_name || &#39; (&#39; || vend_country || &#39;)&#39;FROM Vendors ORDER BY vend_name;</code><br>在 SQL 中的 SELECT 语句中，可使用一 个特殊的操作符来拼接两个列,此操作符可用 加号(+)或两个竖杠(||)</p>
</li>
<li><p><code>SELECT RTRIM(vend_name) || &#39; (&#39; || RTRIM(vend_country) || &#39;)&#39; FROM Vendors ORDER BY vend_name;</code>RTRIM()(正如刚才所见，它去掉字符串右边的 空格)、LTRIM()(去掉字符串左边的空格)以及 TRIM()(去掉字符 串左右两边的空格)。</p>
</li>
<li><p><code>SELECT RTRIM(vend_name) || &#39; (&#39; || RTRIM(vend_country) || &#39;)&#39; AS vend_titile FROM Vendors ORDER BY vend_name;</code>别名(alias)是一个字段或值的 替换名。别名用 AS 关键字赋予</p>
</li>
<li><p><code>SELECT prod_id, quantity,item_price,quantity*item_price AS expanded_price FROM OrderItems WHERE order_num = 20008;</code>计算字段的另一常见用途是对检索出的数据进行算术计算,SQL 支持 *<em>+ - * /*</em></p>
</li>
<li><p>SELECT 语句为测试、检验函数和计算提供了很好的方法。虽然 SELECT 通常用于从表中检索数据，但是省略了 FROM 子句后就是简单地访问和 处理表达式，例如 SELECT 3 * 2;将返回 6，SELECT Trim(‘ abc ‘); 将返回 abc，SELECT Now();使用 Now()函数返回当前日期和时间。 现在你明白了，可以根据需要使用 SELECT 语句进行检验。</p>
</li>
</ol>
<h4 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h4><h5 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h5><table>
<thead>
<tr>
<th>函数</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>提取字符串的组成 部分</td>
<td>Access 使 用 MID() ; DB2 、 Oracle 、 PostgreSQL 和 SQLite 使 用 SUBSTR();MySQL和SQL Server使用SUBSTRING()</td>
</tr>
<tr>
<td>数据类型转换</td>
<td>Access和Oracle使用多个函数，每种类型的转换有一个函数;DB2 和PostgreSQL使用CAST();MariaDB、MySQL和SQL Server使用 CONVERT()</td>
</tr>
<tr>
<td>取当前日期</td>
<td>Access 使 用 NOW() ; DB2 和 PostgreSQL 使 用 CURRENT_DATE ; MariaDB和MySQL使用CURDATE();Oracle使用SYSDATE;SQL Server使用GETDATE();SQLite使用DATE()</td>
</tr>
</tbody></table>
<h5 id="2-使用函数"><a href="#2-使用函数" class="headerlink" title="2.使用函数"></a>2.使用函数</h5><blockquote>
<p>大多数 SQL 实现支持以下类型的函数。</p>
</blockquote>
<ul>
<li>用于处理文本字符串(如删除或填充值，转换值为大写或小写)的文 本函数。</li>
<li>用于在数值数据上进行算术操作(如返回绝对值，进行代数运算)的 数值函数。</li>
<li>用于处理日期和时间值并从这些值中提取特定成分(如返回两个日期 之差，检查日期有效性)的日期和时间函数。</li>
<li>返回 DBMS 正使用的特殊信息(如返回用户登录信息)的系统函数。</li>
</ul>
<ol>
<li><code>SELECT vend_name, UPPER(vend_name) AS vend_name_upcase FROM Vendors ORDER BY vend_name;</code></li>
</ol>
<p>表8-2 常用的文本处理函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LEFT()(或使用子字符串函数)</td>
<td>返回字符串左边的字符</td>
</tr>
<tr>
<td>LENGTH()(也使用DATALENGTH()或LEN())</td>
<td>返回字符串的长度</td>
</tr>
<tr>
<td>LOWER()(Access使用LCASE())</td>
<td>将字符串转换为小写</td>
</tr>
<tr>
<td>LTRIM()</td>
<td>去掉字符串左边的空格</td>
</tr>
<tr>
<td>RIGHT()(或使用子字符串函数)</td>
<td>返回字符串右边的字符</td>
</tr>
<tr>
<td>RTRIM()</td>
<td>去掉字符串右边的空格</td>
</tr>
<tr>
<td>SOUNDEX()</td>
<td>返回字符串的SOUNDEX值,SOUNDEX 是一个将任何文 本串转换为描述其语音表示的字母数字模式的算法</td>
</tr>
<tr>
<td>UPPER()(Access使用UCASE())</td>
<td>将字符串转换为大写</td>
</tr>
</tbody></table>
<p>2.<code>SELECT order_num FROM Orders WHERE strftime(&#39;%Y&#39;, order_date) = &#39;2012&#39;;</code> </p>
<p>表8-3 常用数值处理函数 </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ABS()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>COS()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>EXP()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>SIN()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>SQRT()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>TAN()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<h4 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h4><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h5><p>表9-1 SQL聚集函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
<ol>
<li><code>SELECT AVG(prod_price) AS avg_price FROM Products;</code>AVG()也可以用来确定特定列或行的平均值</li>
<li><code>SELECT COUNT(cust_email) AS num_cust FROM Customers;</code>如果指定列名，则 COUNT()函数会忽略指定列的值为空的行，但如果 COUNT()函数中用的是星号(*)，则不忽略。</li>
<li><code>SELECT SUM(quantity) AS items_ordered FROM OrderItems WHERE order_num = 20005;</code>函数 SUM(quantity)返回订单中所有物品数量之和，WHERE 子句保证只<br>统计某个物品订单中的物品。</li>
</ol>
<h5 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h5><ul>
<li>对所有行执行计算，指定 ALL 参数或不指定参数(因为 ALL 是默认行 为)。</li>
<li>只包含不同的值，指定 DISTINCT 参数。</li>
</ul>
<ol>
<li><code>SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products WHERE vend_id = &#39;DLL01&#39;;</code>如果指定列名，则 DISTINCT 只能用于 COUNT()。DISTINCT 不能用 于 COUNT(*)。类似地，DISTINCT 必须使用列名</li>
<li><code>SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products WHERE vend_id = &#39;DLL01&#39;;</code> DISTINCT 不能用于 COUNT(*)</li>
<li>`SELECT COUNT(*) AS num_items,<pre><code>MIN(prod_price) AS price_min,
MAX(prod_price) AS price_max,
AVG(prod_price) AS price_avg</code></pre>
FROM Products;`单条 SELECT 语句执行了 4 个聚集计算，返回 4 个值(Products<br>表中物品的数目，产品价格的最高值、最低值以及平均值)。</li>
</ol>
<h4 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h4><blockquote>
<p>这一课介绍如何分组数据，以便汇总表内容的子集。这涉及两个新<br>SELECT 语句子句:GROUP BY 子句和 HAVING 子句。</p>
</blockquote>
<h5 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h5><p>1.<code>SELECT vend_id, COUNT(*) AS num_prods FROM Products GROUP BY vend_id;</code>:vend_id 包含产品供应商的 ID， num_prods 为计算字段(用 COUNT(*)函数建立)</p>
<p>在使用GROUP BY子句前，需要知道一些重要的规定。</p>
<ul>
<li>GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套， 更细致地进行数据分组。</li>
<li>如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进 行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以 不能从个别的列取回数据)。</li>
<li>GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式(但 不能是聚集函数)。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。</li>
<li>大多数 SQL 实现不允许 GROUP BY 列带有长度可变的数据类型(如文 本或备注型字段)。</li>
<li>除聚集计算语句外，SELECT 语句中的每一列都必须在 GROUP BY 子句 中给出。</li>
<li>如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。 如果列中有多行 NULL 值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<p>2.<code>SELECT cust_id, COUNT(*) AS orders FROM Orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2;</code> WHERE 在数据分组前进行过滤，HAVING 在数 据分组后进行过滤</p>
<ol start="3">
<li><code>SELECT vend_id, COUNT(*) AS num_prods FROM Products WHERE prod_price &gt;= 4 GROUP BY vend_id HAVING COUNT(*) &gt;= 2;</code>WHERE 子句过滤所有 prod_price 至少为 4 的行，然后按 vend_id 分组数据，HAVING 子句过滤计数为 2 或 2 以上的分组</li>
</ol>
<p>4.<code>SELECT order_num, COUNT(*) AS items FROM OrderItems GROUP BY order_num HAVING COUNT(*) &gt;= 3 ORDER BY items, order_num;</code>使用 GROUP BY 子句按订单号(order_num 列)分组数 据，以便 COUNT(*)函数能够返回每个订单中的物品数目。</p>
<p>表10-2 SELECT子句及其顺序</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
</tbody></table>
<h4 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h4><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><blockquote>
<p>SELECT 语句是 SQL 的查询。我们迄今为止所看到的所有 SELECT 语句都<br>是简单查询，即从单个数据库表中检索数据的单条语句。</p>
</blockquote>
<h5 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h5><blockquote>
<p>使用的数据库表都是关系表</p>
</blockquote>
<ol>
<li><p><code>SELECT order_num FROM OrderItems WHERE prod_id = &#39;RGAN01&#39;;</code> 包含此物品的订单</p>
</li>
<li><p><code>SELECT cust_id FROM Orders WHERE order_num IN (20007,20008);</code>相关的顾客 ID</p>
</li>
<li><p><code>SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = &#39;RGAN01&#39;);</code> 在 SELECT 语句中，子查询总是从内向外处理,包含子查询的 SELECT 语句难以阅读和调试，它们在较为复杂时更是 如此</p>
</li>
<li><p><code>SELECT cust_name, cust_contact FROM Customers WHERE cust_id IN (SELECT cust_id FROM Orders  WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = &#39;RGAN01&#39;));</code>作为子查询的 SELECT 语句只能查询单个列。企图检索多个列将返回 错误。</p>
</li>
<li><p><code>SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders FROM Customers ORDER BY cust_name;</code>比较 Orders 表中的 cust_id 和当前正从 Customers 表中检索的 cust_id:你已经看到了为什么要使用完全限定列名，没有具体指定就会返回错 误结果</p>
</li>
</ol>
<h4 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h4><h5 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h5><blockquote>
<p>SQL 最强大的功能之一就是能在数据查询的执行中联结(join)表。联结 是利用 SQL 的 SELECT 能执行的最重要的操作，很好地理解联结及其语 法是学习 SQL 的极为重要的部分</p>
</blockquote>
<h5 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h5><blockquote>
<p>关系数据可以有效地存储，方便地处理。因此，关系数据库的可<br>伸缩性远比非关系数据库要好。</p>
</blockquote>
<ul>
<li>同一供应商生产的每个产品，其供应商信息都是相同的，对每个产品 重复此信息既浪费时间又浪费存储空间;</li>
<li>如果供应商信息发生变化，例如供应商迁址或电话号码变动，只需修 改一次即可;</li>
<li>如果有重复数据(即每种产品都存储供应商信息)，则很难保证每次 输入该数据的方式都相同。不一致的数据在报表中就很难利用。</li>
</ul>
<h5 id="为什么使用联结"><a href="#为什么使用联结" class="headerlink" title="为什么使用联结"></a>为什么使用联结</h5><blockquote>
<p>简单说，联结是一种机制，用来在一条 SELECT 语句 中关联表，因此称为联结。使用特殊的语法，可以联结多个表返回一组 输出，联结在运行时关联表中正确的行。</p>
</blockquote>
<p>1.<code>SELECT vend_name, prod_name, prod_price FROM Vendors, Products WHERE Vendors.vend_id = Products.vend_id;</code>这两个表用 WHERE 子句正确地联结，WHERE 子句 指示 DBMS 将 Vendors 表中的 vend_id 与 Products 表中的 vend_id 匹配起来。WHERE 子句作为过滤 条件，只包含那些匹配给定条件(这里是联结条件)的行。没有 WHERE 子句，第一个表中的每一行将与第二个表中的每一行配对，而不管它们 逻辑上是否能配在一起。<br>2. <code>SELECT vend_name, prod_name, prod_price FROM Vendors, Products;</code>要保证所有联结都有 WHERE 子句，否则 DBMS 将返回比想要的数据多 得多的数据。</p>
<h5 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h5><blockquote>
<p>目前为止使用的联结称为等值联结(equijoin)，它基于两个表之间的相 等测试。这种联结也称为内联结(inner join)</p>
</blockquote>
<ol>
<li><p><code>SELECT vend_name, prod_name, prod_price FROM Vendors INNER JOIN Products ON Vendors.vend_id = Products.vend_id;</code>此语句中的 SELECT 与前面的 SELECT 语句相同，但 FROM 子句不同。这 里，两个表之间的关系是以 INNER JOIN 指定的部分 FROM 子句。在使用 这种语法时，联结条件用特定的 ON 子句而不是 WHERE 子句给出。传递 给 ON 的实际条件与传递给 WHERE 的相同。</p>
</li>
<li><p><code>SELECT prod_name, vend_name, prod_price, quantity  FROM OrderItems, Products, Vendors WHERE Products.vend_id = Vendors.vend_id AND OrderItems.prod_id = Products.prod_id AND order_num = 20007;</code>DBMS 在运行时关联指定的每个表，以处理联结。这种处理可能非常 耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性 能下降越厉害。</p>
</li>
<li><p><code>SELECT cust_name, cust_contact FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = &#39;RGAN01&#39;;</code></p>
</li>
</ol>
<p>联结是 SQL 中一个最重要、最强大的特性，有效地使用联结需要对关系 数据库设计有基本的了解。</p>
<h4 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h4><h5 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h5><p>SQL 除了可以对列名和计算字段使用别名，还允许给表名起别名。这样 做有两个主要理由:</p>
<ul>
<li>缩短 SQL 语句;</li>
<li>允许在一条 SELECT 语句中多次使用相同的表。</li>
</ul>
<ol>
<li><code>SELECT cust_name, cust_contact FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = &#39;RGAN01&#39;;</code> </li>
</ol>
<h5 id="不同类型连接"><a href="#不同类型连接" class="headerlink" title="不同类型连接"></a>不同类型连接</h5><blockquote>
<p>现在来看三种<br>其他联结:自联结(self-join)、自然联结(natural join)和外联结(outer join)。</p>
</blockquote>
<p><strong>自联结</strong></p>
<ol>
<li><p><code>SELECT cust_id, cust_name, cust_contact FROM Customers WHERE cust_name = (SELECT cust_name FROM Customers WHERE cust_contact = &#39;Jim Jones&#39;);</code> 使用了子查询</p>
</li>
<li><p><code>SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM Customers AS c1, Customers AS c2 WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = &#39;Jim Jones&#39;;</code>自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查 询语句。虽然最终的结果是相同的，但许多 DBMS 处理联结远比处理 子查询快得多。</p>
</li>
</ol>
<p><strong>自然联结</strong></p>
<ol>
<li><code>SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_price FROM Customers AS C, Orders AS O, OrderItems AS OI WHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = &#39;RGAN01&#39;; </code>自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符 (SELECT *)，而对其他表的列使用明确的子集来完成</li>
</ol>
<p><strong>外连接</strong></p>
<ol>
<li><p><code>SELECT Customers.cust_id, Orders.order_num FROM Customers INNER JOIN Orders ON Customers.cust_id = Orders.cust_id;</code>它检索所有顾客及其订单</p>
</li>
<li><p><code>SELECT Customers.cust_id, Orders.order_num FROM Customers LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id;</code>这条 SELECT 语句使用了关键字 OUTER JOIN 来指定联结类型(而不是在 WHERE 子句中指定)。但是，与内联结关联 两个表中的行不同的是，外联结还包括没有关联行的行。在使用 OUTER JOIN 语法时，必须使用 RIGHT 或 LEFT 关键字指定包括其所有行的表<br>(RIGHT 指出的是 OUTER JOIN 右边的表，而 LEFT 指出的是 OUTER JOIN 左边的表)。上面的例子使用 LEFT OUTER JOIN 从 FROM 子句左边的表 (Customers 表)中选择所有行。</p>
</li>
</ol>
<p>SQLite 支持 LEFT OUTER JOIN，但不支持 RIGHT OUTER JOIN。幸好， 如果你确实需要在 SQLite 中使用 RIGHT OUTER JOIN，有一种更简单 的办法，这将在下面的提示中介绍。</p>
<p>FULL OUTER JOIN 的支持<br>Access、MariaDB、MySQL、Open Office Base 和 SQLite 不支持 FULL OUTER JOIN 语法。<br>3. <code> SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ord FROM Customers INNER JOIN Orders ON Customers.cust_id = Orders.cust_id GROUP BY Customers.cust_id;</code>这条SELECT语句使用INNER JOIN将Customers和Orders表互相关联。 GROUP BY 子句按顾客分组数据，因此，函数调用 COUNT(Orders.order_num) 对每个顾客的订单计数，将它作为 num_ord 返回</p>
<ul>
<li>注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。</li>
<li>关于确切的联结语法，应该查看具体的文档，看相应的 DBMS 支持何<br>种语法(大多数 DBMS 使用这两课中描述的某种语法)。</li>
<li>保证使用正确的联结条件(不管采用哪种语法)，否则会返回不正确<br>的数据。</li>
<li>应该总是提供联结条件，否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结<br>类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们 前分别测试每个联结。这会使故障排除更为简单。</li>
</ul>
<h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><blockquote>
<p>本课讲述如何利用 UNION 操作符将多条 SELECT 语句组合成一个结<br>果集</p>
</blockquote>
<h5 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h5><blockquote>
<p>多数 SQL 查询只包含从一个或多个表中返回数据的单条 SELECT 语句。 但是，SQL 也允许执行多个查询(多条 SELECT 语句)，并将结果作为一 个查询结果集返回。这些组合查询通常称为并(union)或复合查询<br>(compound query)。 主要有两种情况需要使用组合查询:<br> 在一个查询中从不同的表返回结构数据;<br> 对一个表执行多个查询，按一个查询返回数据。</p>
</blockquote>
<ol>
<li><p><code>SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;) UNION SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = &#39;Fun4All&#39;;</code></p>
</li>
<li><p><code>SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;) OR cust_name = &#39;Fun4All&#39;;</code>，使用 UNION 可能比使用 WHERE 子句更为复杂。但 对于较复杂的过滤条件，或者从多个表(而不是一个表)中检索数据的 情形，使用 UNION 可能会使处理更简单。</p>
</li>
</ol>
<h5 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h5><ul>
<li>UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键 字 UNION 分隔(因此，如果组合四条 SELECT 语句，将要使用三个 UNION 关键字)。</li>
<li>UNION 中的每个查询必须包含相同的列、表达式或聚集函数(不过， 各个列不需要以相同的次序列出)。</li>
<li>列数据类型必须兼容:类型不必完全相同，但必须是 DBMS 可以隐含 转换的类型(例如，不同的数值类型或不同的日期类型)。</li>
</ul>
<ol>
<li><p><code>SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;) UNION ALL SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = &#39;Fun4All&#39;;</code> UNION 从查询结果集中自动去除了重复的行;果想返回 所有的匹配行，可使用UNION ALL而不是UNION。</p>
</li>
<li><p><code>SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;) UNION SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = &#39;Fun4All&#39; ORDER BY cust_name, cust_contact;</code>SELECT 语句的输出用 ORDER BY 子句排序。在用 UNION 组合查询时，只 能使用一条 ORDER BY 子句，它必须位于最后一条 SELECT 语句之后。虽然 ORDER BY 子句似乎只是最后一条 SELECT 语句的组成部分，但实际上 DBMS 将 用它来排序所有 SELECT 语句返回的所有结果。</p>
</li>
</ol>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><blockquote>
<p>INSERT 用来将行插入(或添加)到数据库表。</p>
</blockquote>
<ul>
<li>插入完整的行;</li>
<li>插入行的一部分;</li>
<li>插入某些查询的结果。</li>
</ul>
<ol>
<li><p>`INSERT INTO Customers<br>VALUES(‘1000000006’,</p>
<pre><code>&#39;Toy Land&#39;,
&#39;123 Any Street&#39;,
&#39;New York&#39;,
&#39;NY&#39;,
&#39;11111&#39;,
&#39;USA&#39;,
NULL,
NULL);`

虽然这种语法很简单，但并不安全，应该尽量避免使用</code></pre>
</li>
</ol>
<ol start="2">
<li>`INSERT INTO Customers(cust_id,<pre><code>               cust_name,
               cust_address,
               cust_city,
               cust_state,
               cust_zip,
               cust_country,
               cust_contact,
               cust_email)
 VALUES(&#39;1000000006&#39;,
    &#39;Toy Land&#39;,
    &#39;123 Any Street&#39;,
    &#39;New York&#39;,
    &#39;NY&#39;,
    &#39;11111&#39;,
    &#39;USA&#39;,
    NULL,
    NULL);`</code></pre>
   因为提供了列名，VALUES 必须以其指定的次序匹配指定的列名，不一定 按各列出现在表中的实际次序。其优点是，即使表的结构改变，这条 INSERT 语句仍然能正确工作。</li>
<li>不管使用哪种 INSERT 语法，VALUES 的数目都必须正确。如果不提供列 名，则必须给每个表列提供一个值;如果提供列名，则必须给列出的每 个列一个值。否则，就会产生一条错误消息，相应的行不能成功插入。</li>
<li>`INSERT INTO Customers(cust_id,<pre><code>               cust_name,
               cust_address,
               cust_city,
               cust_state,
               cust_zip,
               cust_country)
 VALUES(&#39;1000000006&#39;,
        &#39;Toy Land&#39;,
        &#39;123 Any Street&#39;,
        &#39;New York&#39;,
        &#39;NY&#39;,
        &#39;11111&#39;)`</code></pre>
</li>
</ol>
<p>如果表的定义允许，则可以在 INSERT 操作中省略某些列。省略的列 必须满足以下某个条件。</p>
<ul>
<li>该列定义为允许 NULL 值(无值或空值)。</li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li>
</ul>
<h5 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h5><ol>
<li><p>INSERT SELECT 中 SELECT 语句可以包含 WHERE 子句，以过滤插入的数据</p>
<pre><code> INSERT INTO Customers(cust_id,
               cust_contact,
 cust_email,
 cust_name,
 cust_address,
 cust_city,
 cust_state,
 cust_zip,
 cust_country)
 SELECT cust_id,
        cust_contact,
        cust_email,
        cust_name,
        cust_address,
        cust_city,
        cust_state,
        cust_zip,
        cust_country
 FROM CustNew;</code></pre>
</li>
</ol>
<ol start="2">
<li><code>CREATE TABLE CustCopy AS SELECT * FROM Customers;</code></li>
</ol>
<p>在使用SELECT INTO时，需要知道一些事情:</p>
<ul>
<li>任何SELECT选项和子句都可以使用，包括WHERE和GROUP BY;</li>
<li>可利用联结从多个表插入数据;</li>
<li>不管从多少个表中检索数据，数据都只能插入到一个表中。</li>
</ul>
<h4 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h4><blockquote>
<p>如何利用 UPDATE 和 DELETE 语句进一步操作表数据。</p>
</blockquote>
<h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><p>更新(修改)表中的数据，可以使用 UPDATE 语句。有两种使用 UPDATE<br>的方式:</p>
<ul>
<li>更新表中的特定行;</li>
<li>更新表中的所有行。</li>
</ul>
<p>基本的 UPDATE 语句 由三部分组成，分别是:</p>
<ul>
<li>要更新的表;</li>
<li>列名和它们的新值;</li>
<li>确定要更新哪些行的过滤条件。</li>
</ul>
<ol>
<li><p><code>UPDATE Customers SET cust_email = &#39;kim@thetoystore.com&#39; WHERE cust_id = &#39;1000000005&#39;;</code> UPDATE 语句总是以要更新的表名开始。在这个例子中，要更新的表名为 Customers。SET 命令用来将新值赋给被更新的列</p>
</li>
<li><p><code>UPDATE Customers SET cust_contact = &#39;Sam Roberts&#39;, cust_email = &#39;sam@toyland.com&#39; WHERE cust_id = &#39;1000000006&#39;;</code>在更新多个列时，只需要使用一条 SET 命令，每个“列=值”对之间用逗号分隔(最后一列之后不用逗号)</p>
</li>
<li><p>UPDATE 语句中可以使用子查询，使得能用 SELECT 语句检索出的数据 更新列数据</p>
</li>
<li><p><code>UPDATE Customers SET cust_email = NULL WHERE cust_id = &#39;1000000005&#39;;</code>要删除某个列的值，可设置它为 NULL(假如表定义允许 NULL 值)其中 NULL 用来去除 cust_email 列中的值。这与保存空字符串很不同(空 字符串用’’表示，是一个值)，而 NULL 表示没有值。</p>
</li>
</ol>
<h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><p>有两种使用 DELETE<br>的方式:</p>
<ul>
<li>从表中删除特定的行;</li>
<li>从表中删除所有行。</li>
</ul>
<ol>
<li><code>DELETE FROM Customers WHERE cust_id = &#39;1000000006&#39;;</code>不要省略 WHERE 子句 </li>
<li>DELETE 不需要列名或通配符。DELETE 删除整行而不是删除列。要删除 指定的列，请使用 UPDATE 语句。</li>
<li>DELETE 语句从表中删除行，甚至是删除表中所有行。但是，DELETE 不删除表本身。</li>
<li>如果想从表中删除所有行，不要使用 DELETE。可使用 TRUNCATE TABLE 语句，它完成相同的工作，而速度更快</li>
</ol>
<p>下面是许多 SQL 程序员使用 UPDATE 或 DELETE 时所遵循的重要原则。</p>
<ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带 WHERE 子句 的 UPDATE 或 DELETE 语句。</li>
<li>保证每个表都有主键(如果忘记这个内容，请参阅第 12 课)，尽可能 像 WHERE 子句那样使用它(可以指定各主键、多个值或值的范围)。</li>
<li>在 UPDATE 或 DELETE 语句使用 WHERE 子句前，应该先用 SELECT 进 行测试，保证它过滤的是正确的记录，以防编写的 WHERE 子句不正确。</li>
<li>使用强制实施引用完整性的数据库(关于这个内容，请参阅第 12 课)，<br>这样 DBMS 将不允许删除其数据与其他表相关联的行。</li>
<li>有的 DBMS 允许数据库管理员施加约束，防止执行不带 WHERE 子句 的 UPDATE 或 DELETE 语句。如果所采用的 DBMS 支持这个特性，应<br>该使用它。</li>
</ul>
<h4 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h4><p>利用CREATE TABLE创建表，必须给出下列信息:</p>
<ul>
<li>新表的名字，在关键字CREATE TABLE之后给出; </li>
<li>表列的名字和定义，用逗号分隔;</li>
<li>有的 DBMS 还要求指定表的位置。</li>
</ul>
<ol>
<li><p><code> CREATE TABLE Products (     prod_id CHAR(10) NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL, prod_desc VARCHAR(1000)  NULL, );</code></p>
</li>
<li><p>使用NULL值,允许 NULL 值的列也允许在插 入行时不给出该列的值。不允许 NULL 值的列不接受没有列值的行，换 句话说，在插入或更新行时，该列必须有值。</p>
</li>
</ol>
<h5 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h5><p>默认值在 CREATE TABLE 语句的列定义中用关键字 DEFAULT 指定</p>
<h5 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h5><p>以下是使用 ALTER<br>TABLE 时需要考虑的事情。</p>
<ul>
<li>理想情况下，不要在表中包含数据时对其进行更新。应该在表的设 计过程中充分考虑未来可能的需求，避免今后对表的结构做大 改动。</li>
<li>所有的 DBMS 都允许给现有的表增加列，不过对所增加列的数据类型 (以及 NULL 和 DEFAULT 的使用)有所限制。</li>
<li>许多 DBMS 不允许删除或更改表中的列。</li>
<li>多数 DBMS 允许重新命名表中的列。</li>
<li>许多 DBMS 限制对已经填有数据的列进行更改，对未填有数据的列几<br>乎没有限制。</li>
</ul>
<p>使用ALTER TABLE更改表结构，必须给出下面的信息:</p>
<ul>
<li>在 ALTER TABLE 之后给出要更改的表名(该表必须存在，否则将 出错);</li>
<li>列出要做哪些更改。</li>
</ul>
<ol>
<li><code>ALTER TABLE Vendors ADD vend_phone CHAR(20);</code> 这条语句给 Vendors 表增加一个名为 vend_phone 的列，其数据类型 为 CHAR。</li>
<li><code>ALTER TABLE Vendors DROP COLUMN vend_phone;</code>SQLite 对使用 ALTER TABLE 执行的操作有所限制。最重要的一个限制 是，它不支持使用 ALTER TABLE 定义主键和外键，这些必须在最初创 建表时指定。</li>
</ol>
<p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤:</p>
<ol>
<li>用新的列布局创建一个新表;</li>
<li>使用 INSERT SELECT 语句(关于这条语句的详细介绍，请参阅第 15<br>课)从旧表复制数据到新表。有必要的话，可以使用转换函数和计算<br>字段;</li>
<li>检验包含所需数据的新表;</li>
<li>重命名旧表(如果确定，可以删除它);</li>
<li>用旧表原来的名字重命名新表;</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ol>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><p><code>DROP TABLE CustCopy;</code></p>
<h5 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h5><p>SQLite 用户使用 ALTER TABLE 语句。</p>
<h4 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h4><blockquote>
<p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索 数据的查询。<br>SQLite 仅支持只读视图，所以视图可以创建，可以读，但其内容不能 更改。</p>
</blockquote>
<h5 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h5><ul>
<li>重用 SQL 语句。</li>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道 其基本查询细节。</li>
<li>使用表的一部分而不是整个表。</li>
<li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的<br>访问权限。</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>创建视图之后，可以用与表基本相同的方式使用它们。可以对视图执行 SELECT 操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加 和更新数据(添加和更新数据存在某些限制，关于这个内容稍后做介绍)。</p>
<ol>
<li><p><code>CREATE VIEW ProductCustomers AS SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num;</code>删除视图，可以使用DROP语句，其语法为DROP VIEW viewname;。 覆盖(或更新)视图，必须先删除它，然后再重新创建。</p>
</li>
<li><p><code>SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = &#39;RGAN01&#39;;</code>创建不绑定特定数据的视图是一种好办法。</p>
</li>
<li><p><code>SELECT RTRIM(vend_name) || &#39; (&#39; || RTRIM(vend_country) || &#39;)&#39; AS vend_title FROM Vendors ORDER BY vend_name;</code></p>
</li>
<li><p>`CREATE VIEW VendorLocations AS<br>SELECT RTRIM(vend_name) + ‘ (‘ + RTRIM(vend_country) + ‘)’</p>
<pre><code>AS vend_title</code></pre>
<p>FROM Vendors;`</p>
</li>
<li><p><code>CREATE VIEW CustomerEMailList AS SELECT cust_id, cust_name, cust_email FROM Customers WHERE cust_email IS NOT NULL; </code>这里的 WHERE 子句过滤了 cust_email 列中具有 NULL 值的那些 行，使它们不被检索出来。</p>
</li>
<li><p>`CREATE VIEW OrderItemsExpanded AS<br>SELECT order_num,</p>
<pre><code>prod_id,
quantity,`</code></pre>
</li>
<li><p><code>SELECT * FROM OrderItemsExpanded WHERE order_num = 20008;</code>视图非常容易创建，而且很好使用。正确使用，视图可极大 地简化复杂数据的处理。</p>
</li>
</ol>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。 视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新 格式化或保护基础数据。</p>
<h4 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><blockquote>
<p>SQLite 不支持存储过程</p>
</blockquote>
<h4 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h4><blockquote>
<p>如何利用 COMMIT 和 ROLLBACK 语句管理事<br>务处理。</p>
</blockquote>
<h5 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h5><blockquote>
<p>使用事务处理(transaction processing)，通过确保成批的 SQL 操作要么<br>完全执行，要么完全不执行，来维护数据库的完整性。</p>
</blockquote>
<p>术语:</p>
<ul>
<li>事务(transaction)指一组 SQL 语句;</li>
<li>回退(rollback)指撤销指定 SQL 语句的过程;</li>
<li>提交(commit)指将未存储的 SQL 语句结果写入数据库表;</li>
<li>保留点(savepoint)指事务处理中设置的临时占位符(placeholder)，<br>可以对它发布回退(与回退整个事务处理不同)。</li>
</ul>
<p>事务处理用来管理 INSERT、UPDATE 和 DELETE 语句。不能回退 SELECT 语句(回退 SELECT 语句也没有必要)，也不能回退 CREATE 或 DROP 操 作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。</p>
<h5 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h5><p><code>BEGIN TRANSACTION  ... COMMIT TRANSACTION</code>BEGIN TRANSACTION 和 COMMIT TRANSACTION 语句之<br>间的 SQL 必须完全执行或者完全不执行。</p>
<p>使用ROLLBACK:SQL 的 ROLLBACK 命令用来回退(撤销)SQL 语句<br>执行 DELETE 操作，然后用 ROLLBACK 语句撤销。虽然这不 是最有用的例子，但它的确能够说明，在事务处理块中，DELETE 操作(与 INSERT 和 UPDATE 操作一样)并不是最终的结果。</p>
<ol>
<li>使用COMMIT</li>
</ol>
<p>因为涉及更 新两个数据库表 Orders 和 OrderItems，所以使用事务处理块来保证订 单不被部分删除。最后的 COMMIT 语句仅在不出错时写出更改</p>
<ol start="2">
<li>使用简单的 ROLLBACK 和 COMMIT 语句，就可以写入或撤销整个事务。但<br>是，只对简单的事务才能这样做，复杂的事务可能需要部分提交或回退。</li>
</ol>
<h4 id="高级SQL特性"><a href="#高级SQL特性" class="headerlink" title="高级SQL特性"></a>高级SQL特性</h4><blockquote>
<p>许多强有力的<br>特性给用户提供了高级的数据处理技术，如约束。</p>
</blockquote>
<h5 id="主键-1"><a href="#主键-1" class="headerlink" title="主键"></a>主键</h5><p>表中任意列只要满足以下条件，都可以用于主键。</p>
<ul>
<li>任意两行的主键值都不相同。</li>
<li>每行都具有一个主键值(即列中不允许 NULL 值)。</li>
<li>包含主键值的列从不修改或更新。(大多数 DBMS 不允许这么做，但<br>如果你使用的 DBMS 允许这样做，好吧，千万别!)</li>
</ul>
<p>给表的 vend_id 列定义添加关键字 PRIMARY KEY，使其成<br>为主键。</p>
<h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><blockquote>
<p>外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完<br>整性的极其重要部分。<br>其中的表定义使用了 REFERENCES 关键字，它表示 cust_id 中的任何值<br>都必须是 Customers 表的 cust_id 中的值。</p>
</blockquote>
<h5 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h5><p>唯一约束用来保证一列(或一组列)中的数据是唯一的。它们类似于主<br>键，但存在以下重要区别。</p>
<ul>
<li>表可包含多个唯一约束，但每个表只允许一个主键。  唯一约束列可包含 NULL 值。</li>
<li>唯一约束列可修改或更新。</li>
<li>唯一约束列的值可重复使用。</li>
<li>与主键不一样，唯一约束不能用来定义外键。</li>
</ul>
<p>唯一约束的语法类似于其他约束的语法。唯一约束既可以用 UNIQUE 关 键字在表定义中定义，也可以用单独的 CONSTRAINT 定义。</p>
<h5 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h5><p>检查约束用来保证一列(或一组列)中的数据满足一组指定的条件。检<br>查约束的常见用途有以下几点。</p>
<ul>
<li>检查最小或最大值。例如，防止 0 个物品的订单(即使 0 是合法的数)。  指定范围。例如，保证发货日期大于等于今天的日期，但不超过今天<br>起一年后的日期。</li>
<li>只允许特定的值。例如，在性别字段中只允许 M 或 F。</li>
</ul>
<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><blockquote>
<p>索引用来排序数据以加快搜索和排序操作的速度。</p>
</blockquote>
<p>在开始创建索引前，应该记住以下内容。</p>
<ul>
<li>索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。 在执行这些操作时，DBMS 必须动态地更新索引。</li>
<li>索引数据可能要占用大量的存储空间。</li>
<li>并非所有数据都适合做索引。取值不多的数据(如州)不如具有更多<br>可能值的数据(如姓或名)，能通过索引得到那么多的好处。</li>
<li>索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数<br>据，则该数据可能适合做索引。</li>
<li>可以在索引中定义多个列(例如，州加上城市)。这样的索引仅在以州<br>加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。</li>
</ul>
<ol>
<li><code>CREATE INDEX prod_name_ind ON Products (prod_name);</code>引必须唯一命名。这里的索引名 prod_name_ind 在关键字 CREATE INDEX 之后定义。ON 用来指定被索引的表，而索引中包含的列(此例中 仅有一列)在表名后的圆括号中给出</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/18/ios-launch-Optimizing/" rel="prev" title="ios_launch_Optimizing">
      <i class="fa fa-chevron-left"></i> ios_launch_Optimizing
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/15/podfile/" rel="next" title="CocoaPods 之 Podfile">
      CocoaPods 之 Podfile <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE"><span class="nav-number">1.</span> <span class="nav-text">主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2"><span class="nav-number">2.</span> <span class="nav-text">数据检索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2"><span class="nav-number">3.</span> <span class="nav-text">数据排序检索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">过滤数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">高级数据过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">6.</span> <span class="nav-text">用通配符进行过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LIKE-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">6.1.</span> <span class="nav-text">LIKE 操作符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5"><span class="nav-number">7.</span> <span class="nav-text">创建计算字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">1.函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">2.使用函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">9.</span> <span class="nav-text">汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">聚集函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="nav-number">9.2.</span> <span class="nav-text">聚集不同值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-number">10.</span> <span class="nav-text">分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84"><span class="nav-number">10.1.</span> <span class="nav-text">创建分组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">11.</span> <span class="nav-text">使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">11.1.</span> <span class="nav-text">子查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="nav-number">11.2.</span> <span class="nav-text">利用子查询进行过滤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E7%BB%93%E8%A1%A8"><span class="nav-number">12.</span> <span class="nav-text">联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%81%94%E7%BB%93"><span class="nav-number">12.1.</span> <span class="nav-text">联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%A1%A8"><span class="nav-number">12.2.</span> <span class="nav-text">关系表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%81%94%E7%BB%93"><span class="nav-number">12.3.</span> <span class="nav-text">为什么使用联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E8%81%94%E7%BB%93"><span class="nav-number">12.4.</span> <span class="nav-text">内联结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93"><span class="nav-number">13.</span> <span class="nav-text">创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A1%A8%E5%88%AB%E5%90%8D"><span class="nav-number">13.1.</span> <span class="nav-text">使用表别名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E8%BF%9E%E6%8E%A5"><span class="nav-number">13.2.</span> <span class="nav-text">不同类型连接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">14.</span> <span class="nav-text">组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2-1"><span class="nav-number">14.1.</span> <span class="nav-text">组合查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UNION%E8%A7%84%E5%88%99"><span class="nav-number">14.2.</span> <span class="nav-text">UNION规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">15.</span> <span class="nav-text">插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">15.1.</span> <span class="nav-text">插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">16.</span> <span class="nav-text">更新和删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">16.1.</span> <span class="nav-text">更新数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">16.2.</span> <span class="nav-text">删除数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8"><span class="nav-number">17.</span> <span class="nav-text">创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">17.1.</span> <span class="nav-text">指定默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A1%A8"><span class="nav-number">17.2.</span> <span class="nav-text">更新表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-number">17.3.</span> <span class="nav-text">删除表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8"><span class="nav-number">17.4.</span> <span class="nav-text">重命名表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">18.</span> <span class="nav-text">使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">18.1.</span> <span class="nav-text">为什么使用视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">18.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">19.</span> <span class="nav-text">使用存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">管理事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">20.1.</span> <span class="nav-text">事务处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">20.2.</span> <span class="nav-text">控制事务处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7SQL%E7%89%B9%E6%80%A7"><span class="nav-number">21.</span> <span class="nav-text">高级SQL特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE-1"><span class="nav-number">21.1.</span> <span class="nav-text">主键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E9%94%AE"><span class="nav-number">21.2.</span> <span class="nav-text">外键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="nav-number">21.3.</span> <span class="nav-text">唯一约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F"><span class="nav-number">21.4.</span> <span class="nav-text">检查约束</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">21.5.</span> <span class="nav-text">索引</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lhs728</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lhs7248" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lhs7248" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lhs7248@126.com" title="E-Mail → mailto:lhs7248@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lhs728</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">207k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:09</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
